

<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<style>
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
				color: #ffffff;
				min-height: 100dvh;
				overflow: hidden;
			}

			body.is-mobile {
				overflow-y: auto;
			}

			#board {
				position: relative;
				width: 100vw;
				height: 100dvh;
				overflow: hidden;
			}

			body.is-mobile #board {
				height: auto;
				min-height: 100dvh;
			}

			.card {
				position: absolute;
				width: 220px;
				border-radius: 12px;
				box-shadow: 0 16px 35px rgba(0, 0, 0, 0.2);
				background: #fff;
				border: 1px solid rgba(0, 0, 0, 0.08);
				overflow: hidden;
				opacity: 0;
				transform-origin: center;
				transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
					top 0.35s ease, width 0.35s ease, height 0.35s ease,
					border-radius 0.35s ease;
			}

			.card.dragging {
				transition: none;
				box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
			}

			.card.maximized {
				box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
			}

			.card-header {
				display: none;
			}

			.card-body {
				padding: 16px;
				font-size: 16px;
				line-height: 1.4;
				font-weight: 600;
				color: rgba(0, 0, 0, 0.72);
			}

			@media (max-width: 768px) {
				.card {
					width: 180px;
					border-radius: 10px;
				}

				.card-body {
					padding: 14px;
					font-size: 14px;
				}

				.card-title {
					font-size: 12px;
				}
			}

			/* å¯åŠ¨æŒ‰é’®æ ·å¼ */
			#startOverlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background: rgba(0, 0, 0, 0.85);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				z-index: 9999999;
				backdrop-filter: blur(10px);
			}

			#startButton {
				padding: 20px 50px;
				font-size: 24px;
				font-weight: bold;
				color: #fff;
				background: linear-gradient(135deg, #ff6b9d, #c44569);
				border: none;
				border-radius: 50px;
				cursor: pointer;
				box-shadow: 0 10px 30px rgba(255, 107, 157, 0.5);
				transition: all 0.3s ease;
				animation: pulse 2s ease-in-out infinite;
			}

			#startButton:hover {
				transform: scale(1.05);
				box-shadow: 0 15px 40px rgba(255, 107, 157, 0.7);
			}

			#startButton:active {
				transform: scale(0.95);
			}

			@keyframes pulse {
				0%, 100% {
					transform: scale(1);
				}
				50% {
					transform: scale(1.05);
				}
			}

			#startOverlay p {
				color: #fff;
				font-size: 18px;
				margin-bottom: 30px;
				text-align: center;
				opacity: 0.9;
			}

			#musicStatus {
				position: fixed;
				bottom: 20px;
				right: 20px;
				padding: 10px 20px;
				background: rgba(0, 0, 0, 0.7);
				color: #fff;
				border-radius: 20px;
				font-size: 14px;
				z-index: 10000;
				display: none;
			}

			#musicStatus.show {
				display: block;
			}
		</style>
	</head>
	<body>
		<!-- å¯åŠ¨ç•Œé¢ -->
		<div id="startOverlay">	
			<button id="startButton">å¼€å§‹ä½“éªŒ</button>
		</div>

		<div id="board"></div>
		<div id="musicStatus">ğŸµéŸ³ä¹æ’­æ”¾ä¸­...</div>
		<audio id="bgMusic" loop preload="auto">
			<source src="background.mp3" type="audio/mpeg">
		</audio>

		<script>
			const isMobileDevice =
				window.matchMedia('(pointer: coarse)').matches ||
				window.innerWidth <= 768

			if (isMobileDevice) {
				window.location.replace('mobile.html')
			}

			const board = document.getElementById('board')
			const messages = [
				'ä¿æŒå¥½å¿ƒæƒ…',
				'å¤šå–æ°´å“¦',
				'ä»Šå¤©è¾›è‹¦å•¦',
				'æ—©ç‚¹ä¼‘æ¯',
				'è®°å¾—åƒæ°´æœ',
				'å°‘ç†¬å¤œ',
				'æ°¸è¿œé™ªç€ä½ ',
				'ä¿æŒå¾®ç¬‘å‘€',
				'æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±',
				'å¸Œæœ›ä½ åšè‡ªå·±',
				'æ¢¦æƒ³æ€»ä¼šå®ç°',
				'ç›¸ä¿¡è‡ªå·±',
				'ä¹Ÿå¸Œæœ›ä½ å°‘ç”Ÿæ°”',
				'å¾ˆå¤šäº‹æƒ…ä¸è¦è—åœ¨å¿ƒé‡Œ',
				'æœ‰ä½ çš„æ—¥å­æœ€ç”œèœœ',
				'æ¯å¤©çˆ±æˆ‘å¤šä¸€ç‚¹',
				'å’Œä½ ä¸€èµ·å˜è€',
				'é•¿å¤§äº†ä¸€å²è¦æ›´æ‡‚äº‹äº†',
				'ä¹Ÿå¸Œæœ›ä½ è„¾æ°”å¥½ä¸€ç‚¹',
				'å¤©æ°”å†·äº†ï¼Œå¤šç©¿è¡£æœ',
				'è®°å¾—ç»™è‡ªå·±æ”¾æ¾',
				'æ¯å¤©éƒ½è¦å…ƒæ°”æ»¡æ»¡',
				'ä»Šå¤©ä¹Ÿè¦å¥½å¥½çˆ±è‡ªå·±',
				'é€‚å½“ä¼‘æ¯ä¸€ä¸‹',
				'ä»Šå¤©ä¹Ÿè¦å¼€å¿ƒå“¦',
				'è®°å¾—æ—©ç‚¹ç¡è§‰',
				'è®°å¾—åƒæ—©é¤'
			]

			const colors = [
				// ç²‰è‰²ç³»
				'#ffe0e3', // æµ…ç²‰
				'#ffd4f5', // ç²‰ç´«
				'#ffcce0', // ç«ç‘°ç²‰
				'#ffe5ec', // æ¨±èŠ±ç²‰
				'#ffd0e1', // èœœæ¡ƒç²‰
				'#ffb8d1', // çƒ­æƒ…ç²‰
				
				// è“è‰²ç³»
				'#c7f0ff', // å¤©è“
				'#d2f0f8', // å†°è“
				'#cfe2ff', // æµ…è“
				'#d5e8ff', // å¤©ç©ºè“
				'#b8e6ff', // æ¸…æ–°è“
				'#c7deff', // æ·¡è“
				
				// æ©™è‰²ç³»
				'#ffd8a8', // æµ…æ©™
				'#ffe4c4', // æä»è‰²
				'#ffdab9', // æ¡ƒè‰²
				'#ffead0', // é¦™æ§Ÿè‰²
				'#ffecc7', // å¥¶æ²¹æ©™
				
				// ç»¿è‰²ç³»
				'#d9f2d9', // æµ…ç»¿
				'#dff5e1', // è–„è·ç»¿
				'#d4f1d4', // æ¸…æ–°ç»¿
				'#e5f9e7', // å«©ç»¿
				'#d0f0d0', // è‰ç»¿
				
				// ç´«è‰²ç³»
				'#e5d7ff', // æµ…ç´«
				'#f0e5ff', // æ·¡ç´«
				'#e9dcff', // è–°è¡£è‰ç´«
				'#e0d1ff', // æ¢¦å¹»ç´«
				'#ead9ff', // æŸ”å’Œç´«
				
				// é»„è‰²ç³»
				'#f9f7d9', // æµ…é»„
				'#fff9db', // å¥¶é»„
				'#fef6d8', // æŸ æª¬é»„
				'#fffacd', // æ·¡é»„
				'#ffefd5', // é¦™è‰é»„
				
				// å…¶ä»–æ¸©æš–è‰²ç³»
				'#ffe6f0', // çŠç‘šç²‰
				'#ffd5e5', // ç”œå¿ƒç²‰
				'#d4f4ff', // å©´å„¿è“
				'#ffeef8', // æµªæ¼«ç²‰
				'#e0f8f7', // é’ç“·è‰²
				'#ffe8e0', // ææ¡ƒè‰²
				'#f5e5ff', // ä¸é¦™ç´«
				'#e8f8e8', // ç¿¡ç¿ ç»¿
				'#fff0e6', // è±¡ç‰™è‰²
				'#f0f8ff', // çˆ±ä¸½ä¸è“
				'#fef4f4', // è´å£³ç²‰
				'#f0fff0', // èœœç“œç»¿
				'#fff5f7', // è”·è–‡ç²‰
				'#f0f0ff', // å¹½çµç™½
				'#fffaf0'  // èŠ±ç™½è‰²
			]

			const cardStates = new WeakMap()	
			const MAXIMIZED_LAYER = 1000000
			let activeMaximizedCard = null
			let isMobile = false
			const maxCards = 240 
			const spawnInterval = 80 
			const heartGatherDelay = 19000 
			const heartAnimationDuration = 5000 
			const audioDuration = 33000 
			let zIndexCursor = 200
			let animationTriggered = false 
			let currentAnimationTimeouts = [] 

			document.body.classList.remove('is-mobile')

			// è·å–å…ƒç´ 
			const bgMusic = document.getElementById('bgMusic')
			const startOverlay = document.getElementById('startOverlay')
			const startButton = document.getElementById('startButton')
			const musicStatus = document.getElementById('musicStatus')

			let hasStarted = false

			// ç‚¹å‡»å¼€å§‹æŒ‰é’®
			startButton.addEventListener('click', async () => {
				if (hasStarted) return
				hasStarted = true

				try {
					// æ’­æ”¾éŸ³ä¹
					await bgMusic.play()
					console.log('éŸ³ä¹å¼€å§‹æ’­æ”¾')
					
					// æ˜¾ç¤ºéŸ³ä¹çŠ¶æ€
					musicStatus.classList.add('show')
					setTimeout(() => {
						musicStatus.classList.remove('show')
					}, 3000)

					// æ·¡å‡ºå¯åŠ¨ç•Œé¢
					startOverlay.style.transition = 'opacity 0.5s ease'
					startOverlay.style.opacity = '0'
					setTimeout(() => {
						startOverlay.style.display = 'none'
					}, 500)

					// å¼€å§‹ç”Ÿæˆå¡ç‰‡
					startCardGeneration()
				} catch (error) {
					console.error('éŸ³ä¹æ’­æ”¾å¤±è´¥:', error)
					alert('éŸ³é¢‘æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿ background.mp3 æ–‡ä»¶å­˜åœ¨')
				}
			})

			// ç›‘å¬éŸ³é¢‘é”™è¯¯
			bgMusic.addEventListener('error', (e) => {
				console.error('éŸ³é¢‘åŠ è½½é”™è¯¯:', e)
			})

			// ç›‘å¬éŸ³é¢‘æ’­æ”¾çŠ¶æ€
			bgMusic.addEventListener('play', () => {
				console.log('éŸ³é¢‘æ­£åœ¨æ’­æ”¾')
			})

			bgMusic.addEventListener('pause', () => {
				console.log('éŸ³é¢‘å·²æš‚åœ')
			})

			// ç›‘å¬éŸ³é¢‘æ’­æ”¾è¿›åº¦ï¼Œå½“éŸ³é¢‘å¾ªç¯æ—¶é‡ç½®åŠ¨ç”»
			let lastCurrentTime = 0
			bgMusic.addEventListener('timeupdate', () => {
				// æ£€æµ‹éŸ³é¢‘æ˜¯å¦é‡æ–°å¼€å§‹ï¼ˆä»å¤´æ’­æ”¾ï¼‰
				if (lastCurrentTime > 30 && bgMusic.currentTime < 3) {
					console.log('éŸ³é¢‘å¾ªç¯ï¼Œé‡ç½®åŠ¨ç”»')
					resetAndRestartAnimation()
				}
				lastCurrentTime = bgMusic.currentTime
			})

			function randomFrom(array) {
				return array[Math.floor(Math.random() * array.length)]
			}

			function clamp(value, min, max) {
				return Math.min(Math.max(value, min), max)
			}

			// ç”Ÿæˆçˆ±å¿ƒå½¢çŠ¶çš„åæ ‡ç‚¹
			function generateHeartPoints(count) {
				const points = []
				const centerX = window.innerWidth / 2
				const verticalOffset = window.innerHeight * 0.06
				const centerY = window.innerHeight / 2 - verticalOffset

				// ä¼˜å…ˆé€‚åº”è§†å£é«˜åº¦ï¼Œå¹¶åœ¨å¿…è¦æ—¶é™åˆ¶å®½åº¦
				const scaleFromHeight = (window.innerHeight * 0.8) / 30 // 30 è¿‘ä¼¼å¿ƒå½¢å‚ç›´è·¨åº¦
				const maxWidth = window.innerWidth * 0.92
				let scale = scaleFromHeight
				if (scale * 32 > maxWidth) {
					scale = maxWidth / 32
				}

				// ä½¿ç”¨ç›¸åŒçš„ç¼©æ”¾æ¯”ä¿æŒå¿ƒå½¢æ¯”ä¾‹
				for (let i = 0; i < count; i++) {
					const t = (i / count) * Math.PI * 2
					const x = 16 * Math.pow(Math.sin(t), 3)
					const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t))

					points.push({
						x: centerX + x * scale,
						y: centerY + y * scale
					})
				}

				return points
			}

			// è§¦å‘çˆ±å¿ƒåŠ¨ç”»
			function triggerHeartAnimation() {
				if (animationTriggered) return
				animationTriggered = true

				const cards = Array.from(document.querySelectorAll('.card'))
				if (cards.length === 0) return

				const heartPoints = generateHeartPoints(cards.length)
				const centerX = window.innerWidth / 2
				const centerY = window.innerHeight / 2

				// å°†æ‰€æœ‰å¡ç‰‡ç§»åŠ¨åˆ°çˆ±å¿ƒå½¢çŠ¶çš„ä½ç½®
				cards.forEach((card, index) => {
					const state = cardStates.get(card)
					if (!state || state.closing) return

					const point = heartPoints[index % heartPoints.length]
					const cardWidth = card.offsetWidth
					const cardHeight = card.offsetHeight

					// ç¦ç”¨äº¤äº’
					card.style.pointerEvents = 'none'

					// è®¾ç½®è¿‡æ¸¡æ—¶é—´ä¸ºheartAnimationDuration
					card.style.transition = `transform ${heartAnimationDuration}ms ease-in-out, opacity ${heartAnimationDuration}ms ease-in-out, left ${heartAnimationDuration}ms ease-in-out, top ${heartAnimationDuration}ms ease-in-out`

					// ç§»åŠ¨åˆ°çˆ±å¿ƒä½ç½®å¹¶ç¼©å°
					state.left = point.x - cardWidth / 2
					state.top = point.y - cardHeight / 2
					state.scale = isMobile ? 0.40 : 0.60
					state.angle = 0 // æ¢å¤è§’åº¦

					card.style.left = `${state.left}px`
					card.style.top = `${state.top}px`
					applyTransform(card, state)
				})

				// åŠ¨ç”»ç»“æŸåæ˜¾ç¤ºå¿ƒå½¢ä¸­å¤®çš„"æ°¸è¿œçˆ±ä½ "
				setTimeout(() => {
					showFinalCard({ centerX, centerY })
				}, heartAnimationDuration)
			}

			// æ˜¾ç¤ºæœ€ç»ˆçš„"æ°¸è¿œçˆ±ä½ "å¼¹çª—
			function showFinalCard({ centerX, centerY }) {
				const card = document.createElement('div')
				card.className = 'card final-card'

				const cardWidth = isMobile ? 220 : 300

				card.style.background = '#ff6b9d'
				card.style.left = `${centerX - cardWidth / 2}px`
				card.style.top = `${centerY}px`
				card.style.width = `${cardWidth}px`
				card.style.zIndex = MAXIMIZED_LAYER + 1
				card.style.pointerEvents = 'all'
				card.style.opacity = '0'
				card.style.transition = 'transform 600ms ease, opacity 600ms ease, top 600ms ease'

				card.innerHTML = `
					<div class="card-body" style="font-size: 28px; font-weight: bold; text-align: center; color: #fff; padding: 30px;">æ°¸è¿œçˆ±ä½ </div>
				`

				const state = {
					angle: 0,
					scale: 0.4,
					translateX: 0,
					translateY: 0,
					left: centerX - cardWidth / 2,
					top: centerY,
					maximized: false,
					closing: false
				}

				cardStates.set(card, state)
				applyTransform(card, state)
				board.appendChild(card)

				// åŠ¨ç”»æ˜¾ç¤º
				requestAnimationFrame(() => {
					const cardHeight = card.offsetHeight || 0
					const targetTop = centerY - cardHeight / 2

					state.top = targetTop
					card.style.top = `${state.top}px`

					state.scale = 1.12
					applyTransform(card, state)
					card.style.opacity = '1'

					// è½»å¾®çš„è„‰å†²æ•ˆæœ
					setTimeout(() => {
						state.scale = 1
						applyTransform(card, state)
					}, 400)
				})

				// ç‚¹å‡»å¡ç‰‡å…³é—­
				card.addEventListener('click', event => {
					event.stopPropagation()
					card.style.opacity = '0'
					setTimeout(() => card.remove(), 350)
				})
			}

			function applyTransform(card, state) {
				const scale = state.scale ?? 1
				const translateX = state.translateX ?? 0
				const translateY = state.translateY ?? 0
				const angle = state.angle ?? 0
				card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`
			}

			function bringToFront(card) {
				if (card === activeMaximizedCard) {
					card.style.zIndex = MAXIMIZED_LAYER
					return
				}

				zIndexCursor += 1
				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
					zIndexCursor = MAXIMIZED_LAYER - 1
				}

				card.style.zIndex = zIndexCursor
			}

			function setupCardInteractions(card) {
				// å¡ç‰‡ç‚¹å‡»æå‡å±‚çº§
				card.addEventListener('pointerdown', () => {
					bringToFront(card)
				})

				// å³é”®å…³é—­å¡ç‰‡
				card.addEventListener('contextmenu', event => {
					event.preventDefault()
					closeCard(card)
				})
			}

			function closeCard(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return
				if (card === activeMaximizedCard) {
					activeMaximizedCard = null
				}
				state.closing = true
				state.scale = 0.1
				card.style.opacity = '0'
				applyTransform(card, state)

				const handleTransitionEnd = event => {
					if (event.propertyName === 'opacity') {
						card.removeEventListener('transitionend', handleTransitionEnd)
						card.remove()
					}
				}

				card.addEventListener('transitionend', handleTransitionEnd)
			}

			function minimizeCard(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return

				// æœ€å°åŒ–åŠ¨ç”»ï¼šç¼©å°å¹¶æ·¡å‡ºåˆ°åº•éƒ¨ï¼Œç»“æŸæ—¶ç§»é™¤èŠ‚ç‚¹é‡Šæ”¾å†…å­˜
				const runMinimize = () => {
					state.closing = true
					bringToFront(card)
					const bottom = Math.max(window.innerHeight - 24, 0)
					const targetLeft = clamp(
						state.left,
						16,
						Math.max(window.innerWidth - card.offsetWidth - 16, 16)
					)

					state.left = targetLeft
					state.top = bottom
					state.scale = 0.1
					state.angle = 0
					card.style.left = `${targetLeft}px`
					card.style.top = `${bottom}px`
					card.style.opacity = '0.35'
					applyTransform(card, state)

					const handleTransitionEnd = event => {
						if (event.propertyName === 'transform') {
							card.removeEventListener('transitionend', handleTransitionEnd)
							card.remove()
						}
					}

					card.addEventListener('transitionend', handleTransitionEnd)
				}

				if (state.maximized) {
					activeMaximizedCard = null
					state.maximized = false
					card.classList.remove('maximized')
					card.style.borderRadius = '12px'
					state.left = 0
					state.top = 0
					state.scale = 1
					state.angle = 0
					applyTransform(card, state)

					requestAnimationFrame(() => {
						requestAnimationFrame(runMinimize)
					})
					return
				}

				runMinimize()
			}

			function toggleMaximize(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return

				if (state.maximized) {
					restoreFromMaximize(card, state)
				} else {
					maximizeCard(card, state)
				}
			}

			function maximizeCard(card, state) {
				state.beforeMaximize = {
					left: state.left,
					top: state.top,
					scale: state.scale ?? 1,
					width: card.offsetWidth,
					height: card.offsetHeight,
					angle: state.angle ?? 0
				}

				card.classList.add('maximized')
				card.style.left = '0px'
				card.style.top = '0px'
				card.style.width = `${window.innerWidth}px`
				card.style.height = `${window.innerHeight}px`
				card.style.borderRadius = '0'

				state.left = 0
				state.top = 0
				state.scale = 1
				state.angle = 0
				applyTransform(card, state)
				activeMaximizedCard = card
				bringToFront(card)
				state.maximized = true
			}

			function restoreFromMaximize(card, state) {
				const previous = state.beforeMaximize
				if (!previous) return

				card.classList.remove('maximized')
				card.style.left = `${previous.left}px`
				card.style.top = `${previous.top}px`
				card.style.width = `${previous.width}px`
				card.style.height = `${previous.height}px`
				card.style.borderRadius = '12px'

				state.left = previous.left
				state.top = previous.top
				state.scale = previous.scale ?? 1
				state.angle = previous.angle ?? state.angle ?? 0
				applyTransform(card, state)
				state.maximized = false
				if (activeMaximizedCard === card) {
					activeMaximizedCard = null
				}
				bringToFront(card)
				state.lastPosition = { left: state.left, top: state.top }

				setTimeout(() => {
					if (!state.maximized) {
						card.style.width = ''
						card.style.height = ''
						state.width = card.offsetWidth
						state.height = card.offsetHeight
					}
				}, 360)
			}


			function createCard() {
				const card = document.createElement('div')
				card.className = 'card'

				const color = randomFrom(colors)
				const angleRange = isMobile ? 6 : 10
				const angle = (Math.random() - 0.5) * angleRange
				const cardWidth = isMobile ? 180 : 220
				const cardHeight = isMobile ? 130 : 140
				const horizontalMargin = isMobile ? 12 : 16
				const verticalMargin = isMobile ? 12 : 20
				const left =
					horizontalMargin +
					Math.random() *
						Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0)
				const top =
					verticalMargin +
					Math.random() *
						Math.max(window.innerHeight - cardHeight - verticalMargin * 2, 0)

				card.style.background = color
				card.style.left = `${left}px`
				card.style.top = `${top}px`
				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER - 2) {
					zIndexCursor = MAXIMIZED_LAYER - 2
				}
				card.style.zIndex = ++zIndexCursor

				card.innerHTML = `
					<div class="card-body">${randomFrom(messages)}</div>
				`

				const state = {
					angle,
					scale: isMobile ? 0.85 : 0.7,
					translateX: 0,
					translateY: 0,
					left,
					top,
					maximized: false,
					closing: false,
					lastPosition: { left, top }
				}

				cardStates.set(card, state)
				applyTransform(card, state)
				board.appendChild(card)

				state.width = card.offsetWidth
				state.height = card.offsetHeight

				requestAnimationFrame(() => {
					state.scale = 1
					applyTransform(card, state)
					card.style.opacity = '1'
				})

				setupCardInteractions(card)

				if (board.children.length > maxCards) {
					const oldest = board.firstElementChild
					if (oldest && oldest !== card) {
						oldest.remove()
					}
				}
			}

			// å¼€å§‹ç”Ÿæˆå¡ç‰‡çš„å‡½æ•°
			function startCardGeneration() {
				// æ¸…ç©ºä¹‹å‰çš„å®šæ—¶å™¨
				currentAnimationTimeouts.forEach(timeout => clearTimeout(timeout))
				currentAnimationTimeouts = []

				// æŒ‰å‡åŒ€èŠ‚å¥ç”Ÿæˆå¡ç‰‡ç›´åˆ°æ±‡èšå¼€å§‹
				for (let delay = 0; delay < heartGatherDelay; delay += spawnInterval) {
					const timeout = setTimeout(() => {
						if (!animationTriggered) {
							createCard()
						}
					}, delay)
					currentAnimationTimeouts.push(timeout)
				}

				// åˆ°è¾¾æ±‡èšæ—¶é—´åè§¦å‘çˆ±å¿ƒåŠ¨ç”»
				const heartTimeout = setTimeout(() => {
					triggerHeartAnimation()
				}, heartGatherDelay)
				currentAnimationTimeouts.push(heartTimeout)
			}

			// é‡ç½®å¹¶é‡æ–°å¼€å§‹åŠ¨ç”»
			function resetAndRestartAnimation() {
				// æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨
				currentAnimationTimeouts.forEach(timeout => clearTimeout(timeout))
				currentAnimationTimeouts = []

				// é‡ç½®åŠ¨ç”»æ ‡å¿—
				animationTriggered = false

				// æ¸…é™¤æ‰€æœ‰å¡ç‰‡
				const allCards = document.querySelectorAll('.card')
				allCards.forEach(card => {
					card.style.transition = 'opacity 0.3s ease'
					card.style.opacity = '0'
					setTimeout(() => card.remove(), 300)
				})

				// é‡ç½® zIndex
				zIndexCursor = 200
				activeMaximizedCard = null

				// å»¶è¿Ÿä¸€ç‚¹åé‡æ–°å¼€å§‹åŠ¨ç”»
				setTimeout(() => {
					startCardGeneration()
				}, 500)
			}

			window.addEventListener('resize', () => {
				const shouldUseMobile =
					window.matchMedia('(pointer: coarse)').matches ||
					window.innerWidth <= 768
				if (shouldUseMobile) {
					window.location.replace('mobile.html')
					return
				}

				document.body.classList.remove('is-mobile')

				document.querySelectorAll('.card.maximized').forEach(card => {
					card.style.width = `${window.innerWidth}px`
					card.style.height = `${window.innerHeight}px`
				})
			})
		</script>
	</body>
</html>
